{"remainingRequest":"/Users/kimjngyun/frontend/sketch2art/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/kimjngyun/frontend/sketch2art/src/views/Sketcher.vue?vue&type=style&index=0&id=5e9249da&scoped=true&lang=css&","dependencies":[{"path":"/Users/kimjngyun/frontend/sketch2art/src/views/Sketcher.vue","mtime":1619414601665},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/css-loader/dist/cjs.js","mtime":1619073369298},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1619154896205},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/postcss-loader/src/index.js","mtime":1619073370318},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/cache-loader/dist/cjs.js","mtime":1619073328948},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/vue-loader/lib/index.js","mtime":1619154896205}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgpjYW52YXMgewogICAgYmFja2dyb3VuZDogb3JhbmdlOwp9Cg=="},{"version":3,"sources":["Sketcher.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsIA;AACA;AACA","file":"Sketcher.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"canvas-wrapper\">\n    <canvas id=\"canvas\" width=\"512\" height=\"512\"></canvas>\n    <v-btn @click=\"eraseCanvas\">clear</v-btn>\n  </div>\n\n</template>\n\n<script>\nexport default {\n  name: 'CanvasWrapper',\n  data: () => ({\n    context: null,\n    canvas: null,\n    previousX: 0,\n    previousY: 0,\n    currentX: 0,\n    currentY: 0,\n    pressing: false,\n    pressedAt: Date.now(),\n    highlightStartPoint: false,\n    shapes: [],\n    currentShape: [],\n    intervalLastPosition: [-1, -1]\n  }),\n  methods: {\n    eraseCanvas () {\n      this.shapes = []\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n      console.log('erase the canvas')\n    },\n    prepareNewShape () {\n      this.currentShape = [\n        [],\n        [],\n        []\n      ]\n    },\n    storeCoordinates () {\n      if (this.intervalLastPosition[0] !== this.previousX &&\n        this.intervalLastPosition[1] !== this.previousY) {\n        this.intervalLastPosition = [this.previousX, this.previousY]\n        this.currentShape[0].push(this.previousX)\n        this.currentShape[1].push(this.previousY)\n        this.currentShape[2].push(Date.now() - this.pressedAt)\n      }\n    },\n    commitCurrentShape () {\n      this.shapes.push(this.currentShape)\n      /*\n      const drawOptions = {\n        canvasWidth: this.canvas.width,\n        canvasHeight: this.canvas.height\n      }\n      */\n    },\n    draw (mouseEvent) {\n      let timeInterval\n      switch (mouseEvent.type) {\n        case 'mousedown':\n          timeInterval = this.drawMouseDown(mouseEvent)\n          break\n        case 'mouseout':\n          if (!this.pressing) break\n          clearInterval(timeInterval)\n          this.commitCurrentShape()\n          break\n        case 'mouseup':\n          console.log('clearing interval!')\n          this.pressing = false\n          clearInterval(timeInterval)\n          this.commitCurrentShape()\n          break\n        case 'mousemove':\n          if (this.pressing) {\n            this.drawMouseMove(mouseEvent)\n          }\n          break\n      }\n    },\n    drawMouseDown (mouseEvent) {\n      let highlightStartPoint\n      const drawColorStartingPoint = 'black'\n      this.updateXY(mouseEvent)\n      this.pressing = true\n      this.pressedAt = Date.now()\n      highlightStartPoint = true\n      this.prepareNewShape()\n      if (highlightStartPoint) {\n        this.context.beginPath()\n        this.context.fillStyle = drawColorStartingPoint\n        this.context.fillRect(this.currentX, this.currentY, 2, 2)\n        this.context.closePath()\n        highlightStartPoint = false\n      }\n      return window.setInterval(() => this.storeCoordinates(), 9)\n    },\n    drawMouseMove (mouseEvent) {\n      const drawStroke = 4\n      const drawColor = 'black'\n      // TODO: make a config and use it.\n      this.updateXY(mouseEvent)\n      this.context.beginPath()\n      this.context.moveTo(this.previousX, this.previousY)\n      this.context.lineTo(this.currentX, this.currentY)\n      this.context.strokeStyle = drawColor\n      this.context.fillStyle = drawColor\n      this.context.lineCap = 'round'\n      this.context.lineJoin = 'round'\n      this.context.lineWidth = drawStroke\n      this.context.stroke()\n      this.context.closePath()\n    },\n    updateXY (mouseEvent) {\n      this.previousX = this.currentX\n      this.previousY = this.currentY\n      this.currentX = mouseEvent.clientX - this.canvas.offsetLeft\n      this.currentY = mouseEvent.clientY - this.canvas.offsetTop\n    }\n  },\n  mounted () {\n    this.canvas = this.$el.querySelector('#canvas')\n    this.context = this.canvas.getContext('2d')\n    const mouseEvents = ['mousemove', 'mousedown', 'mouseup', 'mouseout']\n    mouseEvents.map(eventName => {\n      this.canvas.addEventListener(eventName, this.draw)\n    })\n    console.log(this.context)\n    console.log(this.canvas)\n  }\n}\n</script>\n\n<style scoped>\ncanvas {\n    background: orange;\n}\n</style>"]}]}