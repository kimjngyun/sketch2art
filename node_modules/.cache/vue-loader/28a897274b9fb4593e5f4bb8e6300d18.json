{"remainingRequest":"/Users/kimjngyun/kimjngyun.github.io/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/kimjngyun/kimjngyun.github.io/src/components/mobileSketch.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/Users/kimjngyun/kimjngyun.github.io/src/components/mobileSketch.vue","mtime":1619774494800},{"path":"/Users/kimjngyun/kimjngyun.github.io/node_modules/css-loader/dist/cjs.js","mtime":1619073369298},{"path":"/Users/kimjngyun/kimjngyun.github.io/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1619154896205},{"path":"/Users/kimjngyun/kimjngyun.github.io/node_modules/postcss-loader/src/index.js","mtime":1619073370318},{"path":"/Users/kimjngyun/kimjngyun.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1619073328948},{"path":"/Users/kimjngyun/kimjngyun.github.io/node_modules/vue-loader/lib/index.js","mtime":1619154896205}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgovKiBTb21lIENTUyBzdHlsaW5nICovCiNza2V0Y2hwYWRhcHAgewogICAgLyogUHJldmVudCBuZWFyYnkgdGV4dCBiZWluZyBoaWdobGlnaHRlZCB3aGVuIGFjY2lkZW50YWxseSBkcmFnZ2luZyBtb3VzZSBvdXRzaWRlIGNvbmZpbmVzIG9mIHRoZSBjYW52YXMgKi8KICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsKICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7CiAgICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7CiAgICAtbW96LXVzZXItc2VsZWN0OiBub25lOwogICAgLW1zLXVzZXItc2VsZWN0OiBub25lOwogICAgdXNlci1zZWxlY3Q6IG5vbmU7Cn0KCi5yaWdodHNpZGUgewogICAgZmxvYXQ6bGVmdDsKICAgIG1hcmdpbi1sZWZ0OjIwcHg7Cn0KI3NrZXRjaHBhZCB7CiAgICBmbG9hdDpsZWZ0OwogICAgaGVpZ2h0OjUxMnB4czsKICAgIHdpZHRoOjUxMnB4OwogICAgYm9yZGVyOjJweCBzb2xpZCAjODg4OwogICAgYm9yZGVyLXJhZGl1czo0cHg7CiAgICBwb3NpdGlvbjpyZWxhdGl2ZTsgLyogTmVjZXNzYXJ5IGZvciBjb3JyZWN0IG1vdXNlIGNvLW9yZHMgaW4gRmlyZWZveCAqLwp9CiNjbGVhcmJ1dHRvbiB7CiAgICBmb250LXNpemU6IDE1cHg7CiAgICBwYWRkaW5nOiAxMHB4OwogICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lOwogICAgYmFja2dyb3VuZDogI2VlZTsKICAgIGJvcmRlcjogMXB4IHNvbGlkICM4ODg7Cn0K"},{"version":3,"sources":["mobileSketch.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"mobileSketch.vue","sourceRoot":"src/components","sourcesContent":["<template>\n    <body onload=\"init()\">\n        <div id=\"sketchpadapp\">\n            <div class=\"rightside\">\n                <canvas id=\"sketchpad\" height=\"512\" width=\"512\">\n                </canvas>\n            </div>\n            <div class=\"btns\">\n                <v-btn @click=\"eraseCanvas\">clear</v-btn>\n                <v-btn @click=\"capture\">submit</v-btn>\n            </div>\n        </div>\n    </body>\n</template>\n\n<script>\nimport { mapActions } from 'vuex'\nexport default {\n    name: 'mobileSketch',\n    data: () => ({\n        canvas: null,\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0,\n        ctx: 0,\n        mouseX: 0,\n        mousey: 0,\n        mouseDown: 0,\n        touchX: 0,\n        touchY: 0,\n        shapes: [],\n    }),\n    methods: {\n        ...mapActions(['addNewImage']),\n        newFile () {\n            const files = this.$el.querySelector('.fileInput').files\n            const newFile = files[files.length - 1]\n\n            this.reader.readAsDataURL(newFile)\n        },\n\n        attachFile () {\n            this.$el.querySelector('.fileInput').click()\n        },\n\n        capture () {\n            const canvas = this.$el.querySelector(\"canvas\")\n            const newImage = canvas.toDataURL(\"image/jpeg\");\n\n            this.addNewImage(newImage)\n            console.log('Captured')\n        },\n        eraseCanvas () {\n            this.shapes = []\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n            this.ctx.fillStyle = \"white\"\n            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n            console.log('erase the canvas')\n        },\n        drawDot(ctx,x,y,size) {\n            // Let's use black by setting RGB values to 0, and 255 alpha (completely opaque)\n            this.r=0; this.g=0; this.b=0; this.a=255;\n\n            // Select a fill style\n            ctx.fillStyle = \"rgba(\"+this.r+\",\"+this.g+\",\"+this.b+\",\"+(this.a/255)+\")\";\n\n            // Draw a filled circle\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, Math.PI*2, true); \n            ctx.closePath();\n            ctx.fill();\n        },\n\n        // Clear the canvas context using the canvas width and height\n        // clearCanvas(canvas,ctx) {\n        //     ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // },\n\n        // Keep track of the mouse button being pressed and draw a dot at current location\n        sketchpad_mouseDown() {\n            this.mouseDown=1;\n            this.drawDot(this.ctx,this.mouseX,this.mouseY,4);\n        },\n\n        // Keep track of the mouse button being released\n        sketchpad_mouseUp() {\n            this.mouseDown=0;\n        },\n\n        // Keep track of the mouse position and draw a dot if mouse button is currently pressed\n        sketchpad_mouseMove(e) { \n            // Update the mouse co-ordinates when moved\n            this.getMousePos(e);\n\n            // Draw a dot if the mouse button is currently being pressed\n            if (this.mouseDown==1) {\n                this.drawDot(this.ctx,this.mouseX,this.mouseY,4);\n            }\n        },\n\n        // Get the current mouse position relative to the top-left of the canvas\n        getMousePos(e) {\n            // if (!e)\n            //     e = event;\n\n            if (e.offsetX) {\n                this.mouseX = e.offsetX;\n                this.mouseY = e.offsetY;\n            }\n            else if (e.layerX) {\n                this.mouseX = e.layerX;\n                this.mouseY = e.layerY;\n            }\n        },\n\n        // Draw something when a touch start is detected\n        sketchpad_touchStart() {\n            // Update the touch co-ordinates\n            this.getTouchPos();\n\n            this.drawDot(this.ctx,this.touchX,this.touchY, 4);\n\n            // Prevents an additional mousedown event being triggered\n            event.preventDefault();\n        },\n\n    // Draw something and prevent the default scrolling when touch movement is detected\n        sketchpad_touchMove(e) { \n            // Update the touch co-ordinates\n            this.getTouchPos(e);\n\n            // During a touchmove event, unlike a mousemove event, we don't need to check if the touch is engaged, since there will always be contact with the screen by definition.\n            this.drawDot(this.ctx,this.touchX,this.touchY, 4); \n\n            // Prevent a scrolling action as a result of this touchmove triggering.\n            event.preventDefault();\n        },\n\n    // Get the touch position relative to the top-left of the canvas\n    // When we get the raw values of pageX and pageY below, they take into account the scrolling on the page\n    // but not the position relative to our target div. We'll adjust them using \"target.offsetLeft\" and\n    // \"target.offsetTop\" to get the correct values in relation to the top left of the canvas.\n        getTouchPos(e) {\n            // if (!e)\n            //     e = event;\n\n            if(e.touches) {\n                if (e.touches.length == 1) { // Only deal with one finger\n                    var touch = e.touches[0]; // Get the information for finger #1\n                    var rect = e.target.getBoundingClientRect();\n                    this.touchX=touch.pageX-rect.x;\n                    this.touchY=touch.pageY-rect.y;\n                    console.log(touch.target.offsetLeft, touch.target.offsetTop)\n                }\n            }\n        },\n\n    },\n    mounted () {\n        // Set-up the canvas and add our event handlers after the page has loaded\n        // Get the specific canvas element from the HTML document\n        this.canvas = document.getElementById('sketchpad');\n        \n        // If the browser supports the canvas tag, get the 2d drawing context for this canvas\n        if (this.canvas.getContext)\n            this.ctx = this.canvas.getContext('2d');\n            this.ctx.fillStyle = \"white\"\n            this.ctx.fillRect(0, 0, 512, 512)\n        // Check that we have a valid context to draw on/with before adding event handlers\n        if (this.ctx) {\n            // React to mouse events on the canvas, and mouseup on the entire document\n            this.canvas.addEventListener('mousedown', this.sketchpad_mouseDown, false);\n            this.canvas.addEventListener('mousemove', this.sketchpad_mouseMove, false);\n            window.addEventListener('mouseup', this.sketchpad_mouseUp, false);\n            // React to touch events on the canvas\n            this.canvas.addEventListener('touchstart', this.sketchpad_touchStart, false);\n            this.canvas.addEventListener('touchmove', this.sketchpad_touchMove, false);\n        }\n    }\n}\n</script>\n\n\n<style>\n/* Some CSS styling */\n#sketchpadapp {\n    /* Prevent nearby text being highlighted when accidentally dragging mouse outside confines of the canvas */\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.rightside {\n    float:left;\n    margin-left:20px;\n}\n#sketchpad {\n    float:left;\n    height:512pxs;\n    width:512px;\n    border:2px solid #888;\n    border-radius:4px;\n    position:relative; /* Necessary for correct mouse co-ords in Firefox */\n}\n#clearbutton {\n    font-size: 15px;\n    padding: 10px;\n    -webkit-appearance: none;\n    background: #eee;\n    border: 1px solid #888;\n}\n</style>\n"]}]}