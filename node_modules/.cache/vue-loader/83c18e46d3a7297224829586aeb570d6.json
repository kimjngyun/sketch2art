{"remainingRequest":"/Users/kimjngyun/frontend/sketch2art/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/kimjngyun/frontend/sketch2art/src/components/UnivCanvas.vue?vue&type=style&index=0&id=032629ae&scoped=true&lang=css&","dependencies":[{"path":"/Users/kimjngyun/frontend/sketch2art/src/components/UnivCanvas.vue","mtime":1621592688684},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/css-loader/dist/cjs.js","mtime":1619073369298},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1619154896205},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/postcss-loader/src/index.js","mtime":1619073370318},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/cache-loader/dist/cjs.js","mtime":1619073328948},{"path":"/Users/kimjngyun/frontend/sketch2art/node_modules/vue-loader/lib/index.js","mtime":1619154896205}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCiN3cmFwVUMgewogICAgZGlzcGxheTogZmxleDsKICAgIHdpZHRoOiA1MTJweDsKICAgIGZsZXgtZmxvdzogcm93IHdyYXA7Cn0KCi5jYW52YXMgewogICAgdG91Y2gtYWN0aW9uOiBub25lOwogICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOwogICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsKICAgIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTsKICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7CiAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7CiAgICB1c2VyLXNlbGVjdDogbm9uZTsKICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsKICAgIGhlaWdodDogNTEycHg7CiAgICBjdXJzb3I6IGNyb3NzaGFpcjsKICAgIG9yZGVyOiAxOwogICAgLyogYm9yZGVyOiAycHggc29saWQgYmxhY2s7ICovCn0KCiNidXR0b25zIHsKICAgIG9yZGVyOiAyOwogICAgYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kOwp9Ci8qICNlcmFzZXIgewogICAgcG9zaXRpb246IGFic29sdXRlOwogICAgdG9wOiAwOwogICAgbGVmdDogMDsKfSAqLwo="},{"version":3,"sources":["UnivCanvas.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+QA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"UnivCanvas.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"wrapUC\">\n    <canvas class=\"canvas\" id=\"sketchpad\" height=\"512\" width=\"512\"></canvas>\n    \n    <div id=\"buttons\">\n        <br/>\n        <v-btn id=\"eraser\" v-on:click=\"eraser\" text color=\"black\" outlined elevation=\"0\">\n            <span v-if=\"isEraser\"> 펜 </span>\n            <span v-else> 지우개 </span>\n        </v-btn>\n        <v-btn v-on:click=\"eraseCanvas\" text color=\"black\" outlined elevation=\"0\">지우기</v-btn>\n        <v-btn v-on:click=\"capture\" text color=\"black\" outlined elevation=\"0\">제출</v-btn>\n    </div>\n    <!-- <button v-on:click=\"\">Add 1</button> -->\n  </div>\n</template>\n\n<script>\nimport axios from 'axios'\nimport { mapActions } from 'vuex'\n// import { mapMutations } from 'vuex'\nexport default {\n    name: 'UnivCanvas',\n    data: () => ({\n        canvas: null,\n        context: null,\n        previousX: 0,\n        previousY: 0,\n        currentX: 0,\n        currentY: 0,\n        mouseDown: 0,\n        mouseX: 0,\n        mousey: 0,\n        touchX: 0,\n        touchY: 0,\n        pressing: false,\n        pressedAt: Date.now(),\n        shapes: [],\n        currnetShape: [],\n        intervalLastPosition: [-1, -1],\n        reader: new FileReader(),\n        stroke: 3,\n        color: 'black',\n        isEraser: false\n    }),\n    prop: {\n        image: Object\n    },\n    methods: {\n        ...mapActions(['addNewImage']),\n        ...mapActions(['resetImage']),\n        newFile () {\n            const files = this.$el.querySelector('.fileInput').files\n            const newFile = files[files.length - 1]\n\n            this.reader.readAsDataURL(newFile)\n        },\n\n        attachFile () {\n            this.$el.querySelector('.fileInput').click()\n        },\n        eraser () {\n            if (this.isEraser === false) {\n                this.color = 'white'\n                this.stroke = 15\n                this.isEraser = true\n                console.log(\"Switch to eraser\")\n            } else {\n                this.color = 'black'\n                this.stroke = 3\n                this.isEraser = false\n                console.log(\"Switch to pen\")\n            }\n\n        },\n        capture () {\n            this.resetImage()\n            const canvas = this.$el.querySelector(\"canvas\")\n            const newImage = canvas.toDataURL(\"image/jpeg\");\n            this.addNewImage(newImage)\n\n            // save sketch img to server\n            const imgBase64 = canvas.toDataURL('image/jpeg', 'image/octet-stream');\n            const decodImg = atob(imgBase64.split(',')[1]);         \n            let array = [];\n\n            for (let i = 0; i < decodImg .length; i++) {\n                array.push(decodImg .charCodeAt(i));\n            }\n\n            const file = new Blob([new Uint8Array(array)], {type: 'image/jpeg'});\n            const fileName = 'canvas_img_' + new Date().getMilliseconds() + '.jpg';\n            let formData = new FormData();\n            formData.append('file', file, fileName);\n            \n            const baseURL = this.$store.getters.urlOf('styleTransferServer')\n            const apiURL = `${baseURL}/api/saveSketch`\n            axios.post(apiURL, formData, {\n                responseType: 'arraybuffer'\n            })\n            console.log('Captured')\n\n        },\n        eraseCanvas () {\n            this.resetImage()\n            this.shapes = []\n            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n            this.context.fillStyle = \"white\"\n            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)\n            console.log('erase the canvas')\n        },\n\n        prepareNewShape () {\n            this.currentShape = [\n                [],\n                [],\n                []\n            ]\n        },\n        storeCoordinates () {\n            if (this.intervalLastPosition[0] !== this.previousX &&\n                this.intervalLastPosition[1] !== this.previousY) {\n                this.intervalLastPosition = [this.previousX, this.previousY]\n                this.currentShape[0].push(this.previousX)\n                this.currentShape[1].push(this.previousY)\n                this.currentShape[2].push(Date.now() - this.pressedAt)\n            }\n        },\n        commitCurrentShape () {\n            this.shapes.push(this.currentShape)\n            console.log(this.currentShape)\n        },\n\n        draw (evt) {\n            let timeInterval\n            switch (evt.type) {\n                case 'pointerdown':\n                case 'mousedown':\n                    timeInterval = this.drawDown(evt)\n                    break\n                case 'pointercancle':\n                case 'touchcancle':\n                case 'mouseout':\n                    if (!this.pressing) break\n                    clearInterval(timeInterval)\n                    this.commitCurrentShape()\n                    break\n                case 'pointerup':\n                case 'touchup':\n                case 'mouseup':\n                    console.log('clearing interval!')\n                    this.pressing = false\n                    clearInterval(timeInterval)\n                    this.commitCurrentShape()\n                    break\n                case 'pointermove':\n                case 'mousemove':\n                    if (this.pressing) {\n                        this.drawMove(evt)\n                    }\n                    break\n                case 'touchmove':\n                    this.drawMove(evt)\n                    evt.preventDefault();\n                    break\n                case 'touchstart':\n                    this.drawDown(evt)\n                    timeInterval = this.drawDown(evt)\n                    evt.preventDefault();\n                    break\n                \n            }\n        },\n        drawDown (evt) {\n            this.updateXY(evt)\n            this.pressing = true\n            this.pressedAt = Date.now()\n\n            this.prepareNewShape()\n\n            return window.setInterval(() => this.storeCoordinates(), 9)\n        },\n        drawMove (evt) {\n            const drawStroke = this.stroke\n            const drawColor = this.color\n            this.updateXY(evt)\n            this.context.beginPath()\n            this.context.moveTo(this.previousX, this.previousY)\n            this.context.lineTo(this.currentX, this.currentY)\n            this.context.strokeStyle = drawColor\n            this.context.fillStyle = drawColor\n            this.context.lineCap = 'round'\n            this.context.lineJoin = 'round'\n            this.context.lineWidth = drawStroke\n            this.context.stroke()\n            this.context.closePath()\n        },\n        updateXY (evt) {\n            this.previousX = this.currentX\n            this.previousY = this.currentY\n\n            if(evt.targetTouches) {\n                // Prefer Touch Events\n                this.getTouchPos(evt)\n                this.currentX = this.touchX\n                this.currentY = this.touchY\n            } else {\n                this.getMousePos(evt)\n                this.currentX = this.mouseX\n                this.currentY = this.mouseY\n            }\n        },\n\n        getMousePos (evt) {\n            if (evt.offsetX) {\n                this.mouseX = evt.offsetX;\n                this.mouseY = evt.offsetY;\n            }\n            else if (evt.layerX) {\n                this.mouseX = evt.layerX;\n                this.mouseY = evt.layerY;\n            }\n        },\n\n        getTouchPos (evt) {\n            if(evt.touches) {\n                if (evt.touches.length == 1) { // Only deal with one finger\n                    var touch = evt.touches[0]; // Finger #1\n                    var rect = evt.target.getBoundingClientRect();\n                    this.touchX=touch.pageX-rect.x;\n                    this.touchY=touch.pageY-rect.y;\n                }\n            console.log(\"gotTP\")\n            }\n        }\n\n    },\n    mounted () {\n        this.canvas = this.$el.querySelector(\"canvas\")\n        this.context = this.canvas.getContext('2d')\n\n\t\tthis.context.fillStyle = \"white\"\n\t\tthis.context.fillRect(0, 0, 512, 512)\n\n        if (window.PointerEvent) {\n            // Add Pointer Event Listener\n            this.canvas.addEventListener('pointerdown', this.draw);\n            this.canvas.addEventListener('pointermove', this.draw);\n            this.canvas.addEventListener('pointerup', this.draw);\n            this.canvas.addEventListener('pointercancel', this.draw);\n            } else {\n            // Add Touch Listener\n            this.canvas.addEventListener('touchstart', this.draw);\n            this.canvas.addEventListener('touchmove', this.draw);\n            this.canvas.addEventListener('touchend', this.draw);\n            this.canvas.addEventListener('touchcancel', this.draw);\n            // Add Mouse Listener\n            this.canvas.addEventListener('mousemove', this.draw);\n            this.canvas.addEventListener('mousedown', this.draw);\n            this.canvas.addEventListener('mouseup', this.draw);\n            this.canvas.addEventListener('mousecout', this.draw);\n        }\n        this.reader.addEventListener('load', () => {\n            this.addNewImage(this.reader.result)\n        })\n    }\n}\n</script>\n\n\n<style scoped>\n#wrapUC {\n    display: flex;\n    width: 512px;\n    flex-flow: row wrap;\n}\n\n.canvas {\n    touch-action: none;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    position: relative;\n    height: 512px;\n    cursor: crosshair;\n    order: 1;\n    /* border: 2px solid black; */\n}\n\n#buttons {\n    order: 2;\n    align-content: space-around;\n}\n/* #eraser {\n    position: absolute;\n    top: 0;\n    left: 0;\n} */\n</style>\n"]}]}