{"remainingRequest":"/Users/kimjngyun/sketch2art/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/kimjngyun/sketch2art/src/components/mobileSketch.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/kimjngyun/sketch2art/src/components/mobileSketch.vue","mtime":1619952442896},{"path":"/Users/kimjngyun/sketch2art/node_modules/cache-loader/dist/cjs.js","mtime":1619073328948},{"path":"/Users/kimjngyun/sketch2art/node_modules/babel-loader/lib/index.js","mtime":1619154893880},{"path":"/Users/kimjngyun/sketch2art/node_modules/cache-loader/dist/cjs.js","mtime":1619073328948},{"path":"/Users/kimjngyun/sketch2art/node_modules/vue-loader/lib/index.js","mtime":1619154896205}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBheGlvcyBmcm9tICdheGlvcycKaW1wb3J0IHsgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnCi8vIGltcG9ydCB7IG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnCmV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICdtb2JpbGVTa2V0Y2gnLAogICAgZGF0YTogKCkgPT4gKHsKICAgICAgICBjYW52YXM6IG51bGwsCiAgICAgICAgcjogMCwKICAgICAgICBnOiAwLAogICAgICAgIGI6IDAsCiAgICAgICAgYTogMCwKICAgICAgICBjdHg6IDAsCiAgICAgICAgbW91c2VYOiAwLAogICAgICAgIG1vdXNleTogMCwKICAgICAgICBtb3VzZURvd246IDAsCiAgICAgICAgdG91Y2hYOiAwLAogICAgICAgIHRvdWNoWTogMCwKICAgICAgICBzaGFwZXM6IFtdLAogICAgICAgIHN0cm9rZTogMgogICAgfSksCiAgICBwcm9wOiB7CiAgICAgICAgaW1hZ2U6IE9iamVjdAogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICAuLi5tYXBBY3Rpb25zKFsnYWRkTmV3SW1hZ2UnXSksCiAgICAgICAgLi4ubWFwQWN0aW9ucyhbJ3Jlc2V0SW1hZ2UnXSksCiAgICAgICAgbmV3RmlsZSAoKSB7CiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmZpbGVJbnB1dCcpLmZpbGVzCiAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGUgPSBmaWxlc1tmaWxlcy5sZW5ndGggLSAxXQoKICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVhZEFzRGF0YVVSTChuZXdGaWxlKQogICAgICAgIH0sCgogICAgICAgIGF0dGFjaEZpbGUgKCkgewogICAgICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZmlsZUlucHV0JykuY2xpY2soKQogICAgICAgIH0sCgogICAgICAgIGNhcHR1cmUgKCkgewogICAgICAgICAgICB0aGlzLnJlc2V0SW1hZ2UoKQogICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCJjYW52YXMiKQogICAgICAgICAgICBjb25zdCBuZXdJbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoImltYWdlL2pwZWciKTsKCiAgICAgICAgICAgIHRoaXMuYWRkTmV3SW1hZ2UobmV3SW1hZ2UpCgoKICAgICAgICAgICAgLy8g7ISc67KEIOyggOyepSDtlZjripQg67aA67aECiAgICAgICAgICAgIGNvbnN0IGltZ0Jhc2U2NCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAnaW1hZ2Uvb2N0ZXQtc3RyZWFtJyk7CiAgICAgICAgICAgIGNvbnN0IGRlY29kSW1nID0gYXRvYihpbWdCYXNlNjQuc3BsaXQoJywnKVsxXSk7ICAgICAgICAgCiAgICAgICAgICAgIGxldCBhcnJheSA9IFtdOwoKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZEltZyAubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIGFycmF5LnB1c2goZGVjb2RJbWcgLmNoYXJDb2RlQXQoaSkpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGFycmF5KV0sIHt0eXBlOiAnaW1hZ2UvanBlZyd9KTsKICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSAnY2FudmFzX2ltZ18nICsgbmV3IERhdGUoKS5nZXRNaWxsaXNlY29uZHMoKSArICcuanBnJzsKICAgICAgICAgICAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7CiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUsIGZpbGVOYW1lKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IGJhc2VVUkwgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLnVybE9mKCdzdHlsZVRyYW5zZmVyU2VydmVyJykKICAgICAgICAgICAgY29uc3QgYXBpVVJMID0gYCR7YmFzZVVSTH0vZmlsZVVwbG9hZGAKICAgICAgICAgICAgYXhpb3MucG9zdChhcGlVUkwsIGZvcm1EYXRhLCB7CiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicKICAgICAgICAgICAgfSkKICAgICAgICAgICAgY29uc29sZS5sb2coJ0NhcHR1cmVkJykKCiAgICAgICAgICAgIHRoaXMuaW1hZ2Uuc3VibWl0dGVkID0gdHJ1ZQogICAgICAgIH0sCiAgICAgICAgZXJhc2VDYW52YXMgKCkgewogICAgICAgICAgICB0aGlzLnJlc2V0SW1hZ2UoKQogICAgICAgICAgICB0aGlzLnNoYXBlcyA9IFtdCiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KQogICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSAid2hpdGUiCiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcmFzZSB0aGUgY2FudmFzJykKICAgICAgICB9LAogICAgICAgIGRyYXdEb3QoY3R4LHgseSxzaXplKSB7CiAgICAgICAgICAgIC8vIExldCdzIHVzZSBibGFjayBieSBzZXR0aW5nIFJHQiB2YWx1ZXMgdG8gMCwgYW5kIDI1NSBhbHBoYSAoY29tcGxldGVseSBvcGFxdWUpCiAgICAgICAgICAgIHRoaXMucj0wOyB0aGlzLmc9MDsgdGhpcy5iPTA7IHRoaXMuYT0yNTU7CgogICAgICAgICAgICAvLyBTZWxlY3QgYSBmaWxsIHN0eWxlCiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAicmdiYSgiK3RoaXMucisiLCIrdGhpcy5nKyIsIit0aGlzLmIrIiwiKyh0aGlzLmEvMjU1KSsiKSI7CgogICAgICAgICAgICAvLyBEcmF3IGEgZmlsbGVkIGNpcmNsZQogICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2l6ZSwgMCwgTWF0aC5QSSoyLCB0cnVlKTsgCiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTsKICAgICAgICAgICAgY3R4LmZpbGwoKTsKICAgICAgICB9LAoKICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzIGNvbnRleHQgdXNpbmcgdGhlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0CiAgICAgICAgLy8gY2xlYXJDYW52YXMoY2FudmFzLGN0eCkgewogICAgICAgIC8vICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgLy8gfSwKCiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbW91c2UgYnV0dG9uIGJlaW5nIHByZXNzZWQgYW5kIGRyYXcgYSBkb3QgYXQgY3VycmVudCBsb2NhdGlvbgogICAgICAgIHNrZXRjaHBhZF9tb3VzZURvd24oKSB7CiAgICAgICAgICAgIHRoaXMubW91c2VEb3duPTE7CiAgICAgICAgICAgIHRoaXMuZHJhd0RvdCh0aGlzLmN0eCx0aGlzLm1vdXNlWCx0aGlzLm1vdXNlWSx0aGlzLnN0cm9rZSk7CiAgICAgICAgfSwKCiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbW91c2UgYnV0dG9uIGJlaW5nIHJlbGVhc2VkCiAgICAgICAgc2tldGNocGFkX21vdXNlVXAoKSB7CiAgICAgICAgICAgIHRoaXMubW91c2VEb3duPTA7CiAgICAgICAgfSwKCiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbW91c2UgcG9zaXRpb24gYW5kIGRyYXcgYSBkb3QgaWYgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBwcmVzc2VkCiAgICAgICAgc2tldGNocGFkX21vdXNlTW92ZShlKSB7IAogICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1vdXNlIGNvLW9yZGluYXRlcyB3aGVuIG1vdmVkCiAgICAgICAgICAgIHRoaXMuZ2V0TW91c2VQb3MoZSk7CgogICAgICAgICAgICAvLyBEcmF3IGEgZG90IGlmIHRoZSBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQKICAgICAgICAgICAgaWYgKHRoaXMubW91c2VEb3duPT0xKSB7CiAgICAgICAgICAgICAgICB0aGlzLmRyYXdEb3QodGhpcy5jdHgsdGhpcy5tb3VzZVgsdGhpcy5tb3VzZVksdGhpcy5zdHJva2UpOwogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBvZiB0aGUgY2FudmFzCiAgICAgICAgZ2V0TW91c2VQb3MoZSkgewogICAgICAgICAgICAvLyBpZiAoIWUpCiAgICAgICAgICAgIC8vICAgICBlID0gZXZlbnQ7CgogICAgICAgICAgICBpZiAoZS5vZmZzZXRYKSB7CiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlWCA9IGUub2Zmc2V0WDsKICAgICAgICAgICAgICAgIHRoaXMubW91c2VZID0gZS5vZmZzZXRZOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKGUubGF5ZXJYKSB7CiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlWCA9IGUubGF5ZXJYOwogICAgICAgICAgICAgICAgdGhpcy5tb3VzZVkgPSBlLmxheWVyWTsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIC8vIERyYXcgc29tZXRoaW5nIHdoZW4gYSB0b3VjaCBzdGFydCBpcyBkZXRlY3RlZAogICAgICAgIHNrZXRjaHBhZF90b3VjaFN0YXJ0KCkgewogICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRvdWNoIGNvLW9yZGluYXRlcwogICAgICAgICAgICB0aGlzLmdldFRvdWNoUG9zKCk7CgogICAgICAgICAgICB0aGlzLmRyYXdEb3QodGhpcy5jdHgsdGhpcy50b3VjaFgsdGhpcy50b3VjaFksIHRoaXMuc3Ryb2tlKTsKCiAgICAgICAgICAgIC8vIFByZXZlbnRzIGFuIGFkZGl0aW9uYWwgbW91c2Vkb3duIGV2ZW50IGJlaW5nIHRyaWdnZXJlZAogICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIH0sCgogICAgLy8gRHJhdyBzb21ldGhpbmcgYW5kIHByZXZlbnQgdGhlIGRlZmF1bHQgc2Nyb2xsaW5nIHdoZW4gdG91Y2ggbW92ZW1lbnQgaXMgZGV0ZWN0ZWQKICAgICAgICBza2V0Y2hwYWRfdG91Y2hNb3ZlKGUpIHsgCiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdG91Y2ggY28tb3JkaW5hdGVzCiAgICAgICAgICAgIHRoaXMuZ2V0VG91Y2hQb3MoZSk7CgogICAgICAgICAgICAvLyBEdXJpbmcgYSB0b3VjaG1vdmUgZXZlbnQsIHVubGlrZSBhIG1vdXNlbW92ZSBldmVudCwgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBpZiB0aGUgdG91Y2ggaXMgZW5nYWdlZCwgc2luY2UgdGhlcmUgd2lsbCBhbHdheXMgYmUgY29udGFjdCB3aXRoIHRoZSBzY3JlZW4gYnkgZGVmaW5pdGlvbi4KICAgICAgICAgICAgdGhpcy5kcmF3RG90KHRoaXMuY3R4LHRoaXMudG91Y2hYLHRoaXMudG91Y2hZLCB0aGlzLnN0cm9rZSk7IAoKICAgICAgICAgICAgLy8gUHJldmVudCBhIHNjcm9sbGluZyBhY3Rpb24gYXMgYSByZXN1bHQgb2YgdGhpcyB0b3VjaG1vdmUgdHJpZ2dlcmluZy4KICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICB9LAoKICAgIC8vIEdldCB0aGUgdG91Y2ggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IG9mIHRoZSBjYW52YXMKICAgIC8vIFdoZW4gd2UgZ2V0IHRoZSByYXcgdmFsdWVzIG9mIHBhZ2VYIGFuZCBwYWdlWSBiZWxvdywgdGhleSB0YWtlIGludG8gYWNjb3VudCB0aGUgc2Nyb2xsaW5nIG9uIHRoZSBwYWdlCiAgICAvLyBidXQgbm90IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBvdXIgdGFyZ2V0IGRpdi4gV2UnbGwgYWRqdXN0IHRoZW0gdXNpbmcgInRhcmdldC5vZmZzZXRMZWZ0IiBhbmQKICAgIC8vICJ0YXJnZXQub2Zmc2V0VG9wIiB0byBnZXQgdGhlIGNvcnJlY3QgdmFsdWVzIGluIHJlbGF0aW9uIHRvIHRoZSB0b3AgbGVmdCBvZiB0aGUgY2FudmFzLgogICAgICAgIGdldFRvdWNoUG9zKGUpIHsKICAgICAgICAgICAgLy8gaWYgKCFlKQogICAgICAgICAgICAvLyAgICAgZSA9IGV2ZW50OwoKICAgICAgICAgICAgaWYoZS50b3VjaGVzKSB7CiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7IC8vIE9ubHkgZGVhbCB3aXRoIG9uZSBmaW5nZXIKICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07IC8vIEdldCB0aGUgaW5mb3JtYXRpb24gZm9yIGZpbmdlciAjMQogICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3VjaFg9dG91Y2gucGFnZVgtcmVjdC54OwogICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hZPXRvdWNoLnBhZ2VZLXJlY3QueTsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0b3VjaC50YXJnZXQub2Zmc2V0TGVmdCwgdG91Y2gudGFyZ2V0Lm9mZnNldFRvcCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgfSwKICAgIG1vdW50ZWQgKCkgewogICAgICAgIC8vIFNldC11cCB0aGUgY2FudmFzIGFuZCBhZGQgb3VyIGV2ZW50IGhhbmRsZXJzIGFmdGVyIHRoZSBwYWdlIGhhcyBsb2FkZWQKICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIGNhbnZhcyBlbGVtZW50IGZyb20gdGhlIEhUTUwgZG9jdW1lbnQKICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdza2V0Y2hwYWQnKTsKICAgICAgICAKICAgICAgICAvLyBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgY2FudmFzIHRhZywgZ2V0IHRoZSAyZCBkcmF3aW5nIGNvbnRleHQgZm9yIHRoaXMgY2FudmFzCiAgICAgICAgaWYgKHRoaXMuY2FudmFzLmdldENvbnRleHQpCiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gIndoaXRlIgogICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCA1MTIsIDUxMikKICAgICAgICAvLyBDaGVjayB0aGF0IHdlIGhhdmUgYSB2YWxpZCBjb250ZXh0IHRvIGRyYXcgb24vd2l0aCBiZWZvcmUgYWRkaW5nIGV2ZW50IGhhbmRsZXJzCiAgICAgICAgaWYgKHRoaXMuY3R4KSB7CiAgICAgICAgICAgIC8vIFJlYWN0IHRvIG1vdXNlIGV2ZW50cyBvbiB0aGUgY2FudmFzLCBhbmQgbW91c2V1cCBvbiB0aGUgZW50aXJlIGRvY3VtZW50CiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuc2tldGNocGFkX21vdXNlRG93biwgZmFsc2UpOwogICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnNrZXRjaHBhZF9tb3VzZU1vdmUsIGZhbHNlKTsKICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnNrZXRjaHBhZF9tb3VzZVVwLCBmYWxzZSk7CiAgICAgICAgICAgIC8vIFJlYWN0IHRvIHRvdWNoIGV2ZW50cyBvbiB0aGUgY2FudmFzCiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnNrZXRjaHBhZF90b3VjaFN0YXJ0LCBmYWxzZSk7CiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuc2tldGNocGFkX3RvdWNoTW92ZSwgZmFsc2UpOwogICAgICAgIH0KICAgIH0KfQo="},{"version":3,"sources":["mobileSketch.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"mobileSketch.vue","sourceRoot":"src/components","sourcesContent":["<template>\n    <v-layout class=\"univSketch\">\n        <v-card elevation=\"0\">\n            <canvas id=\"sketchpad\" height=\"512\" width=\"512\">\n            </canvas>\n            <v-card-text>\n                If you submit, we considered as you agree that\n                <br>\n                the sketch image can be used as a dataset.\n            </v-card-text>\n            \n            <v-card-actions>\n                <v-btn text color=\"black\" outlined elevation=\"0\" @click=\"eraseCanvas\">clear</v-btn>\n                <v-btn text color=\"black\" outlined elevation=\"0\" @click=\"capture\">submit</v-btn>\n            </v-card-actions>\n        </v-card>\n    </v-layout>\n</template>\n\n<script>\nimport axios from 'axios'\nimport { mapActions } from 'vuex'\n// import { mapMutations } from 'vuex'\nexport default {\n    name: 'mobileSketch',\n    data: () => ({\n        canvas: null,\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0,\n        ctx: 0,\n        mouseX: 0,\n        mousey: 0,\n        mouseDown: 0,\n        touchX: 0,\n        touchY: 0,\n        shapes: [],\n        stroke: 2\n    }),\n    prop: {\n        image: Object\n    },\n    methods: {\n        ...mapActions(['addNewImage']),\n        ...mapActions(['resetImage']),\n        newFile () {\n            const files = this.$el.querySelector('.fileInput').files\n            const newFile = files[files.length - 1]\n\n            this.reader.readAsDataURL(newFile)\n        },\n\n        attachFile () {\n            this.$el.querySelector('.fileInput').click()\n        },\n\n        capture () {\n            this.resetImage()\n            const canvas = this.$el.querySelector(\"canvas\")\n            const newImage = canvas.toDataURL(\"image/jpeg\");\n\n            this.addNewImage(newImage)\n\n\n            // 서버 저장 하는 부분\n            const imgBase64 = canvas.toDataURL('image/jpeg', 'image/octet-stream');\n            const decodImg = atob(imgBase64.split(',')[1]);         \n            let array = [];\n\n            for (let i = 0; i < decodImg .length; i++) {\n                array.push(decodImg .charCodeAt(i));\n            }\n\n            const file = new Blob([new Uint8Array(array)], {type: 'image/jpeg'});\n            const fileName = 'canvas_img_' + new Date().getMilliseconds() + '.jpg';\n            let formData = new FormData();\n            formData.append('file', file, fileName);\n            \n            const baseURL = this.$store.getters.urlOf('styleTransferServer')\n            const apiURL = `${baseURL}/fileUpload`\n            axios.post(apiURL, formData, {\n                responseType: 'arraybuffer'\n            })\n            console.log('Captured')\n\n            this.image.submitted = true\n        },\n        eraseCanvas () {\n            this.resetImage()\n            this.shapes = []\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n            this.ctx.fillStyle = \"white\"\n            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n            console.log('erase the canvas')\n        },\n        drawDot(ctx,x,y,size) {\n            // Let's use black by setting RGB values to 0, and 255 alpha (completely opaque)\n            this.r=0; this.g=0; this.b=0; this.a=255;\n\n            // Select a fill style\n            ctx.fillStyle = \"rgba(\"+this.r+\",\"+this.g+\",\"+this.b+\",\"+(this.a/255)+\")\";\n\n            // Draw a filled circle\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, Math.PI*2, true); \n            ctx.closePath();\n            ctx.fill();\n        },\n\n        // Clear the canvas context using the canvas width and height\n        // clearCanvas(canvas,ctx) {\n        //     ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // },\n\n        // Keep track of the mouse button being pressed and draw a dot at current location\n        sketchpad_mouseDown() {\n            this.mouseDown=1;\n            this.drawDot(this.ctx,this.mouseX,this.mouseY,this.stroke);\n        },\n\n        // Keep track of the mouse button being released\n        sketchpad_mouseUp() {\n            this.mouseDown=0;\n        },\n\n        // Keep track of the mouse position and draw a dot if mouse button is currently pressed\n        sketchpad_mouseMove(e) { \n            // Update the mouse co-ordinates when moved\n            this.getMousePos(e);\n\n            // Draw a dot if the mouse button is currently being pressed\n            if (this.mouseDown==1) {\n                this.drawDot(this.ctx,this.mouseX,this.mouseY,this.stroke);\n            }\n        },\n\n        // Get the current mouse position relative to the top-left of the canvas\n        getMousePos(e) {\n            // if (!e)\n            //     e = event;\n\n            if (e.offsetX) {\n                this.mouseX = e.offsetX;\n                this.mouseY = e.offsetY;\n            }\n            else if (e.layerX) {\n                this.mouseX = e.layerX;\n                this.mouseY = e.layerY;\n            }\n        },\n\n        // Draw something when a touch start is detected\n        sketchpad_touchStart() {\n            // Update the touch co-ordinates\n            this.getTouchPos();\n\n            this.drawDot(this.ctx,this.touchX,this.touchY, this.stroke);\n\n            // Prevents an additional mousedown event being triggered\n            event.preventDefault();\n        },\n\n    // Draw something and prevent the default scrolling when touch movement is detected\n        sketchpad_touchMove(e) { \n            // Update the touch co-ordinates\n            this.getTouchPos(e);\n\n            // During a touchmove event, unlike a mousemove event, we don't need to check if the touch is engaged, since there will always be contact with the screen by definition.\n            this.drawDot(this.ctx,this.touchX,this.touchY, this.stroke); \n\n            // Prevent a scrolling action as a result of this touchmove triggering.\n            event.preventDefault();\n        },\n\n    // Get the touch position relative to the top-left of the canvas\n    // When we get the raw values of pageX and pageY below, they take into account the scrolling on the page\n    // but not the position relative to our target div. We'll adjust them using \"target.offsetLeft\" and\n    // \"target.offsetTop\" to get the correct values in relation to the top left of the canvas.\n        getTouchPos(e) {\n            // if (!e)\n            //     e = event;\n\n            if(e.touches) {\n                if (e.touches.length == 1) { // Only deal with one finger\n                    var touch = e.touches[0]; // Get the information for finger #1\n                    var rect = e.target.getBoundingClientRect();\n                    this.touchX=touch.pageX-rect.x;\n                    this.touchY=touch.pageY-rect.y;\n                    console.log(touch.target.offsetLeft, touch.target.offsetTop)\n                }\n            }\n        },\n\n    },\n    mounted () {\n        // Set-up the canvas and add our event handlers after the page has loaded\n        // Get the specific canvas element from the HTML document\n        this.canvas = document.getElementById('sketchpad');\n        \n        // If the browser supports the canvas tag, get the 2d drawing context for this canvas\n        if (this.canvas.getContext)\n            this.ctx = this.canvas.getContext('2d');\n            this.ctx.fillStyle = \"white\"\n            this.ctx.fillRect(0, 0, 512, 512)\n        // Check that we have a valid context to draw on/with before adding event handlers\n        if (this.ctx) {\n            // React to mouse events on the canvas, and mouseup on the entire document\n            this.canvas.addEventListener('mousedown', this.sketchpad_mouseDown, false);\n            this.canvas.addEventListener('mousemove', this.sketchpad_mouseMove, false);\n            window.addEventListener('mouseup', this.sketchpad_mouseUp, false);\n            // React to touch events on the canvas\n            this.canvas.addEventListener('touchstart', this.sketchpad_touchStart, false);\n            this.canvas.addEventListener('touchmove', this.sketchpad_touchMove, false);\n        }\n    }\n}\n</script>\n\n\n<style>\n/* Some CSS styling */\n#sketchpadapp {\n    /* Prevent nearby text being highlighted when accidentally dragging mouse outside confines of the canvas */\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n#sketchpad {\n    height: 512px;\n    width: 512px;\n    border: 2px solid black;\n    border-radius: 10px;\n    position: relative; /* Necessary for correct mouse co-ords in Firefox */\n}\n</style>\n"]}]}